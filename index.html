<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kismet</title>
<style>
  :root {
    --bg: #0f0f0f;
    --surface: #1a1a2e;
    --surface2: #16213e;
    --accent: #e94560;
    --accent2: #0f3460;
    --text: #eee;
    --text2: #999;
    --green: #00d97e;
    --purple: #9d4edd;
    --radius: 12px;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  header {
    padding: 24px;
    text-align: center;
  }
  header h1 { font-size: 1.5rem; font-weight: 600; }

  #status {
    color: var(--text2);
    font-size: 0.85rem;
    min-height: 20px;
    margin-bottom: 12px;
    transition: color 0.2s;
  }
  #status.active { color: var(--green); }
  #status.listening { color: var(--accent); }
  #status.sleeping { color: var(--purple); }

  #chat {
    flex: 1;
    width: 100%;
    max-width: 640px;
    overflow-y: auto;
    padding: 0 16px 120px;
  }
  .msg {
    margin: 8px 0;
    padding: 12px 16px;
    border-radius: var(--radius);
    max-width: 85%;
    line-height: 1.5;
    font-size: 0.95rem;
    position: relative;
  }
  .msg.user {
    background: var(--accent2);
    margin-left: auto;
    border-bottom-right-radius: 4px;
  }
  .msg.assistant {
    background: var(--surface);
    margin-right: auto;
    border-bottom-left-radius: 4px;
  }
  .msg.streaming {
    border-left: 2px solid var(--accent);
  }
  .msg.streaming::after {
    content: 'â–‹';
    animation: blink 1s infinite;
    color: var(--accent);
  }
  .msg.interrupted {
    opacity: 0.6;
    border-left: 2px solid var(--text2);
  }
  .msg.interrupted::after {
    content: ' [interrupted]';
    color: var(--text2);
    font-size: 0.75rem;
  }
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
  .msg .meta {
    font-size: 0.7rem;
    color: var(--text2);
    margin-top: 4px;
  }

  #controls {
    position: fixed;
    bottom: 0;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
    padding: 20px;
    background: linear-gradient(transparent, var(--bg) 30%);
  }

  .btn {
    width: 72px;
    height: 72px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    transition: transform 0.15s, box-shadow 0.15s, background 0.3s;
  }
  .btn:hover { transform: scale(1.05); }
  .btn:active { transform: scale(0.95); }

  /* Audio level visualizer ring around mic button */
  #micBtn {
    background: var(--accent);
    box-shadow: 0 0 0 0 rgba(233,69,96,0.4);
    position: relative;
  }
  #audioLevel {
    position: absolute;
    inset: -4px;
    border-radius: 50%;
    border: 2px solid transparent;
    pointer-events: none;
    transition: border-color 0.05s, box-shadow 0.05s;
  }
  #audioLevel.active {
    border-color: rgba(0,217,126,0.6);
  }

  /* Error toast */
  .error-toast {
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(233,69,96,0.15);
    border: 1px solid rgba(233,69,96,0.3);
    color: var(--accent);
    padding: 8px 20px;
    border-radius: 8px;
    font-size: 0.85rem;
    z-index: 200;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    max-width: 90%;
    text-align: center;
  }
  .error-toast.show { opacity: 1; }

  /* Reconnect banner */
  #reconnectBanner {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: rgba(233,69,96,0.9);
    color: white;
    text-align: center;
    padding: 8px;
    font-size: 0.85rem;
    z-index: 300;
    cursor: pointer;
  }
  #reconnectBanner.show { display: block; }

  #micBtn.recording {
    animation: pulse 1.5s infinite;
    background: #ff2244;
  }
  #micBtn.vad-active {
    background: var(--green);
  }
  #micBtn.vad-active.recording {
    animation: pulse-green 1.5s infinite;
    background: #00ff99;
  }
  #micBtn.sleeping {
    background: var(--purple);
    animation: pulse-sleep 3s infinite;
  }
  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(233,69,96,0.6); }
    70% { box-shadow: 0 0 0 20px rgba(233,69,96,0); }
    100% { box-shadow: 0 0 0 0 rgba(233,69,96,0); }
  }
  @keyframes pulse-green {
    0% { box-shadow: 0 0 0 0 rgba(0,217,126,0.6); }
    70% { box-shadow: 0 0 0 20px rgba(0,217,126,0); }
    100% { box-shadow: 0 0 0 0 rgba(0,217,126,0); }
  }
  @keyframes pulse-sleep {
    0%, 100% { box-shadow: 0 0 0 0 rgba(157,78,221,0.4); opacity: 0.7; }
    50% { box-shadow: 0 0 0 15px rgba(157,78,221,0); opacity: 1; }
  }

  #clearBtn {
    width: 48px; height: 48px;
    background: var(--surface2);
    color: var(--text2);
    font-size: 16px;
  }

  #wakeToggle {
    width: 48px; height: 48px;
    background: var(--surface2);
    color: var(--text2);
    font-size: 14px;
  }
  #wakeToggle.active {
    background: var(--purple);
    color: var(--bg);
  }

  /* Speaker verification UI */
  .header-row {
    display: flex;
    align-items: center;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }
  .header-btn {
    background: var(--surface2);
    color: var(--text2);
    border: none;
    padding: 6px 14px;
    border-radius: 8px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: background 0.2s;
  }
  .header-btn:hover { background: var(--accent2); color: var(--text); }
  .header-btn.active { background: var(--green); color: var(--bg); }

  .verify-badge {
    display: inline-block;
    font-size: 0.65rem;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 6px;
    vertical-align: middle;
  }
  .verify-badge.pass { background: rgba(0,217,126,0.2); color: var(--green); }
  .verify-badge.fail { background: rgba(233,69,96,0.2); color: var(--accent); }

  /* Enrollment modal */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  .modal-overlay.show { display: flex; }
  .modal {
    background: var(--surface);
    border-radius: var(--radius);
    padding: 28px;
    max-width: 420px;
    width: 90%;
    text-align: center;
  }
  .modal h2 { font-size: 1.2rem; margin-bottom: 16px; }
  .modal p { color: var(--text2); font-size: 0.9rem; margin-bottom: 12px; line-height: 1.5; }
  .modal .prompt-text {
    font-size: 1rem;
    color: var(--text);
    background: var(--surface2);
    padding: 12px;
    border-radius: 8px;
    margin: 12px 0;
    font-style: italic;
  }
  .modal .progress {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin: 16px 0;
  }
  .modal .progress .dot {
    width: 12px; height: 12px;
    border-radius: 50%;
    background: var(--surface2);
    transition: background 0.3s;
  }
  .modal .progress .dot.done { background: var(--green); }
  .modal .progress .dot.active { background: var(--accent); animation: pulse 1s infinite; }
  .modal-btn {
    background: var(--accent);
    color: white;
    border: none;
    padding: 10px 24px;
    border-radius: 8px;
    font-size: 0.9rem;
    cursor: pointer;
    margin: 4px;
  }
  .modal-btn.secondary {
    background: var(--surface2);
    color: var(--text2);
  }
  .modal-btn:disabled { opacity: 0.5; cursor: default; }

  .msg.rejected {
    opacity: 0.4;
    border-left: 2px solid var(--accent);
  }

  @media (max-width: 480px) {
    .msg { max-width: 92%; }
  }
</style>
</head>
<body>

<header>
  <h1>Kismet</h1>
  <div class="header-row">
    <button class="header-btn" id="enrollBtn" title="Enroll your voice for speaker verification">ðŸŽ¤ Enroll Voice</button>
    <button class="header-btn" id="verifyToggle" title="Toggle speaker verification">ðŸ”’ Verify: Off</button>
  </div>
</header>

<!-- Enrollment Modal -->
<div class="modal-overlay" id="enrollModal">
  <div class="modal">
    <h2 id="enrollTitle">Voice Enrollment</h2>
    <p id="enrollDesc">Read each sentence aloud to enroll your voice. This lets Kismet verify it's you speaking.</p>
    <div class="prompt-text" id="enrollPrompt"></div>
    <div class="progress" id="enrollProgress"></div>
    <p id="enrollInfo" style="font-size:0.8rem"></p>
    <div>
      <button class="modal-btn" id="enrollRecordBtn">ðŸŽ¤ Record</button>
      <button class="modal-btn secondary" id="enrollCancelBtn">Cancel</button>
    </div>
  </div>
</div>

<!-- Reconnect banner -->
<div id="reconnectBanner">Connection lost. Click to retry.</div>

<!-- Error toast -->
<div class="error-toast" id="errorToast"></div>

<div id="status">Connecting...</div>
<div id="chat"></div>

<div id="controls">
  <button class="btn" id="clearBtn" title="Clear conversation">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/></svg>
  </button>
  <button class="btn" id="micBtn" title="Hold to talk, or say the wake word">
    <div id="audioLevel"></div>
    <svg id="micIcon" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
  </button>
  <button class="btn" id="wakeToggle" title="Toggle wake word mode">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v4a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z"/><path d="M19 10v1a7 7 0 0 1-14 0v-1"/><path d="M12 19v2"/><path d="M8 21h8"/><path d="M3 3l18 18" stroke-width="2"/></svg>
  </button>
</div>

<!-- VAD library -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.19/dist/bundle.min.js"></script>

<script>
const SAMPLE_RATE = 16000;
const WAKE_CHUNK_SIZE = 2048;  // ~128ms chunks for wake word detection (must be power of 2)
const WAKE_CHUNK_MS = 128;

let ws;
const chatEl = document.getElementById('chat');
const statusEl = document.getElementById('status');
const micBtn = document.getElementById('micBtn');
const clearBtn = document.getElementById('clearBtn');
const wakeToggle = document.getElementById('wakeToggle');
const audioLevelEl = document.getElementById('audioLevel');
const errorToastEl = document.getElementById('errorToast');
const reconnectBanner = document.getElementById('reconnectBanner');

// ---- State ----
let wakeWordEnabled = false;  // Server has wake word enabled
let wakeWordActive = false;   // User has wake word mode on
let clientState = 'awake';    // 'sleeping' or 'awake'
let vadInstance = null;
let isProcessing = false;     // Waiting for LLM response
let isSpeaking = false;       // Audio is playing
let wakeWordName = null;
let idleTimeout = 30;

// Wake word streaming
let streamingAudioContext = null;
let streamingWorklet = null;
let streamingSource = null;
let streamingStream = null;

// ---- Reconnection state ----
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 10;
const BASE_RECONNECT_MS = 1000;
let reconnectTimer = null;
let wasConnected = false;       // Track if we had a successful connection before
let savedWakeWordActive = false; // Restore wake word state on reconnect

// ---- Streaming state ----
let streamingMsgEl = null;
let streamingText = '';

// ---- Error toast ----
let errorToastTimer = null;
function showError(text, durationMs = 4000) {
  errorToastEl.textContent = text;
  errorToastEl.classList.add('show');
  clearTimeout(errorToastTimer);
  errorToastTimer = setTimeout(() => errorToastEl.classList.remove('show'), durationMs);
}

// ---- Audio level visualizer ----
let audioLevelRAF = null;
function updateAudioLevel(rms) {
  // rms is 0..1, map to visual intensity
  if (rms > 0.01) {
    audioLevelEl.classList.add('active');
    const spread = Math.min(rms * 40, 12); // max 12px glow
    const alpha = Math.min(rms * 3, 0.8);
    audioLevelEl.style.boxShadow = `0 0 ${spread}px rgba(0,217,126,${alpha})`;
  } else {
    audioLevelEl.classList.remove('active');
    audioLevelEl.style.boxShadow = 'none';
  }
}

// ---- Audio queue for sequential playback ----
const audioQueue = [];
let currentAudio = null;

function enqueueAudio(b64) {
  audioQueue.push(b64);
  playNext();
}

function playNext() {
  if (currentAudio || audioQueue.length === 0) return;

  isSpeaking = true;
  const b64 = audioQueue.shift();
  const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
  const blob = new Blob([bytes], { type: 'audio/wav' });
  const url = URL.createObjectURL(blob);
  currentAudio = new Audio(url);

  currentAudio.onended = () => {
    URL.revokeObjectURL(url);
    currentAudio = null;
    if (audioQueue.length === 0) {
      isSpeaking = false;
    }
    playNext();
  };

  currentAudio.onerror = () => {
    URL.revokeObjectURL(url);
    currentAudio = null;
    if (audioQueue.length === 0) {
      isSpeaking = false;
    }
    playNext();
  };

  currentAudio.play().catch(() => {
    currentAudio = null;
    if (audioQueue.length === 0) {
      isSpeaking = false;
    }
    playNext();
  });
}

function stopPlayback() {
  if (currentAudio) {
    currentAudio.pause();
    currentAudio.currentTime = 0;
    currentAudio = null;
  }
  audioQueue.length = 0;
  isSpeaking = false;
}

function interrupt() {
  console.log('[Interrupt] User interrupted');
  stopPlayback();
  
  if (streamingMsgEl) {
    streamingMsgEl.classList.remove('streaming');
    streamingMsgEl.classList.add('interrupted');
    streamingMsgEl = null;
    streamingText = '';
  }
  
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'cancel' }));
  }
  
  isProcessing = false;
}

// ---- WebSocket ----
function connect() {
  if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }

  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}/ws`);

  ws.onopen = () => {
    console.log('[WS] Connected');
    reconnectAttempts = 0;
    reconnectBanner.classList.remove('show');
    if (wasConnected) {
      setStatus('Reconnected! Loading models...', 'active');
    } else {
      setStatus('Loading models... (first time may take a moment)');
    }
    wasConnected = true;
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);

    if (msg.type === 'ready') {
      wakeWordEnabled = msg.wake_word_enabled;
      wakeWordName = msg.wake_word;
      idleTimeout = msg.idle_timeout || 30;
      
      if (wakeWordEnabled) {
        wakeToggle.style.display = '';
        console.log(`[WakeWord] Available: "${wakeWordName}", idle timeout: ${idleTimeout}s`);
        // Restore wake word state on reconnect, or auto-enable on first connect
        if (savedWakeWordActive || !wasConnected || wakeWordActive) {
          enableWakeWordMode();
        } else {
          updateStatusForMode();
        }
      } else {
        wakeToggle.style.display = 'none';
        // No wake word â€” go straight to VAD (hands-free) mode
        clientState = 'awake';
        micBtn.classList.add('vad-active');
        setStatus('Listening...', 'listening');
        startVAD();
      }
      // Check speaker enrollment
      ws.send(JSON.stringify({ type: 'check_enrollment' }));

    } else if (msg.type === 'error') {
      // Graceful error display from server
      console.warn('[Server Error]', msg.text);
      showError(msg.text);
      isProcessing = false;
      updateStatusForMode();

    } else if (msg.type === 'wake') {
      // Wake word detected!
      console.log(`[WakeWord] Detected! Score: ${msg.score}`);
      handleWake();
    } else if (msg.type === 'sleep') {
      // Server says go back to sleep
      console.log('[State] Server requested sleep');
      handleSleep();
    } else if (msg.type === 'status') {
      setStatus(msg.text, 'active');
    } else if (msg.type === 'transcript') {
      let metaText = msg.time ? `${msg.time}s` : null;
      if (msg.role === 'user' && lastVerifyScore !== null && lastVerifyScore < 1.0) {
        const badge = lastVerifyScore >= 0.65 ? 'âœ“' : 'âœ—';
        metaText = (metaText || '') + ` Â· speaker ${badge} ${lastVerifyScore.toFixed(2)}`;
      }
      addMessage(msg.role, msg.text, metaText);
    } else if (msg.type === 'stream_start') {
      streamingText = '';
      streamingMsgEl = document.createElement('div');
      streamingMsgEl.className = 'msg assistant streaming';
      chatEl.appendChild(streamingMsgEl);
      chatEl.scrollTop = chatEl.scrollHeight;
    } else if (msg.type === 'token') {
      streamingText += msg.text;
      if (streamingMsgEl) {
        streamingMsgEl.textContent = streamingText;
        chatEl.scrollTop = chatEl.scrollHeight;
      }
    } else if (msg.type === 'audio_chunk') {
      enqueueAudio(msg.data);
    } else if (msg.type === 'stream_end') {
      if (streamingMsgEl) {
        streamingMsgEl.classList.remove('streaming');
        streamingMsgEl.textContent = msg.text;

        const t = msg.times;
        const meta = document.createElement('div');
        meta.className = 'meta';
        const parts = [`STT ${t.stt}s`, `LLM ${t.llm}s`, `TTS ${t.tts}s`];
        if (t.first_sentence) {
          parts.push(`first audio ${t.first_sentence}s`);
        }
        meta.textContent = parts.join(' Â· ');
        streamingMsgEl.appendChild(meta);
        chatEl.scrollTop = chatEl.scrollHeight;
      }
      streamingMsgEl = null;
      streamingText = '';
      isProcessing = false;
      updateStatusForMode();
    } else if (msg.type === 'cancelled') {
      console.log('[WS] Server confirmed cancel');
      isProcessing = false;
      updateStatusForMode();
    } else if (msg.type === 'audio') {
      // Legacy single audio
      playAudio(msg.data);
      const t = msg.times;
      setStatus(`STT ${t.stt}s Â· LLM ${t.llm}s Â· TTS ${t.tts}s`, 'active');
      isProcessing = false;

    // Speaker verification messages
    } else if (msg.type === 'verified') {
      lastVerifyScore = msg.score;
    } else if (msg.type === 'rejected') {
      lastVerifyScore = msg.score;
      const div = document.createElement('div');
      div.className = 'msg user rejected';
      div.textContent = '[Voice not recognized]';
      const m = document.createElement('div');
      m.className = 'meta';
      m.textContent = `Score: ${msg.score} Â· ${msg.time}s`;
      div.appendChild(m);
      chatEl.appendChild(div);
      chatEl.scrollTop = chatEl.scrollHeight;
      isProcessing = false;
      updateStatusForMode();

    } else if (msg.type === 'enroll_status') {
      if (msg.status === 'sample_received') {
        enrollStep = msg.samples;
        updateEnrollStep();
      } else if (msg.status === 'complete') {
        enrolled = true;
        verifyEnabled = true;
        updateVerifyUI();
        enrollTitle.textContent = 'âœ… Enrolled!';
        enrollPrompt.textContent = 'Your voice has been enrolled successfully.';
        enrollProgress.innerHTML = '';
        enrollInfo.textContent = '';
        enrollRecordBtn.style.display = 'none';
        enrollCancelBtn.textContent = 'Close';
        setTimeout(hideEnrollModal, 1500);
      } else if (msg.status === 'error') {
        enrollInfo.textContent = msg.message || 'Error';
      }

    } else if (msg.type === 'enrollment_info') {
      enrolled = msg.enrolled;
      verifyEnabled = msg.verify_enabled;
      updateVerifyUI();

    } else if (msg.type === 'verify_toggled') {
      verifyEnabled = msg.enabled;
      updateVerifyUI();
    }
  };

  ws.onclose = () => {
    console.log('[WS] Disconnected');
    stopWakeWordStreaming();
    stopPlayback();

    // Save state for restore on reconnect
    savedWakeWordActive = wakeWordActive;

    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      const delay = Math.min(BASE_RECONNECT_MS * Math.pow(2, reconnectAttempts), 30000);
      reconnectAttempts++;
      setStatus(`Disconnected... Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`, '');
      console.log(`[WS] Reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);
      reconnectTimer = setTimeout(connect, delay);
    } else {
      // Max retries reached â€” show clickable banner
      setStatus('Connection lost', '');
      reconnectBanner.classList.add('show');
    }
  };

  ws.onerror = (err) => {
    console.error('[WS] Error:', err);
  };
}

// ---- Wake Word Mode ----
async function enableWakeWordMode() {
  wakeWordActive = true;
  wakeToggle.classList.add('active');
  clientState = 'sleeping';
  micBtn.classList.add('sleeping');
  micBtn.classList.remove('vad-active');
  
  // Stop VAD if it was running
  if (vadInstance) {
    vadInstance.pause();
  }
  
  // Tell server we're sleeping
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'set_state', state: 'sleeping' }));
  }
  
  // Start streaming audio for wake word detection
  await startWakeWordStreaming();
  
  setStatus(`Say "${wakeWordName}" to wake me`, 'sleeping');
  console.log('[WakeWord] Mode enabled, streaming started');
}

function disableWakeWordMode() {
  wakeWordActive = false;
  wakeToggle.classList.remove('active');
  clientState = 'awake';
  micBtn.classList.remove('sleeping');
  
  // Stop streaming
  stopWakeWordStreaming();
  
  // Stop VAD if running
  if (vadInstance) {
    vadInstance.pause();
  }
  
  updateStatusForMode();
  console.log('[WakeWord] Mode disabled');
  
  // Tell server
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'set_state', state: 'awake' }));
  }
}

async function handleWake() {
  clientState = 'awake';
  micBtn.classList.remove('sleeping');
  micBtn.classList.add('vad-active');
  
  // Stop wake word streaming first (releases mic)
  stopWakeWordStreaming();
  
  // Small delay to let mic release fully
  await new Promise(r => setTimeout(r, 200));
  
  // Start VAD for speech capture
  setStatus('Listening...', 'listening');
  await startVAD();
  console.log('[WakeWord] Transitioned to VAD listening');
}

function handleSleep() {
  if (!wakeWordActive) return;  // Only if wake word mode is on
  
  clientState = 'sleeping';
  micBtn.classList.add('sleeping');
  micBtn.classList.remove('vad-active');
  micBtn.classList.remove('recording');
  
  // Stop VAD
  if (vadInstance) {
    vadInstance.pause();
  }
  
  // Restart wake word streaming
  startWakeWordStreaming();
  
  setStatus(`Say "${wakeWordName}" to wake me`, 'sleeping');
}

// ---- Wake Word Audio Streaming ----
async function startWakeWordStreaming() {
  if (streamingAudioContext) return;  // Already streaming
  
  try {
    streamingStream = await navigator.mediaDevices.getUserMedia({
      audio: { sampleRate: SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true }
    });
    
    streamingAudioContext = new AudioContext({ sampleRate: SAMPLE_RATE });
    
    // Use ScriptProcessor for simplicity (AudioWorklet would be better for production)
    streamingSource = streamingAudioContext.createMediaStreamSource(streamingStream);
    const processor = streamingAudioContext.createScriptProcessor(WAKE_CHUNK_SIZE, 1, 1);
    
    processor.onaudioprocess = (e) => {
      const float32 = e.inputBuffer.getChannelData(0);

      // Audio level visualization (always, regardless of state)
      let sum = 0;
      for (let i = 0; i < float32.length; i++) sum += float32[i] * float32[i];
      updateAudioLevel(Math.sqrt(sum / float32.length));

      if (clientState !== 'sleeping' || !ws || ws.readyState !== WebSocket.OPEN) return;
      
      const int16 = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        int16[i] = Math.max(-32768, Math.min(32767, Math.round(float32[i] * 32767)));
      }
      
      const b64 = arrayBufferToBase64(int16.buffer);
      ws.send(JSON.stringify({ type: 'audio_stream', data: b64 }));
    };
    
    streamingSource.connect(processor);
    processor.connect(streamingAudioContext.destination);
    streamingWorklet = processor;
    
    console.log('[WakeWord] Audio streaming started');
  } catch (err) {
    console.error('[WakeWord] Failed to start streaming:', err);
    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
      showError('Mic access denied â€” enable microphone in browser settings', 6000);
    }
  }
}

function stopWakeWordStreaming() {
  updateAudioLevel(0);
  if (streamingWorklet) {
    streamingWorklet.disconnect();
    streamingWorklet = null;
  }
  if (streamingSource) {
    streamingSource.disconnect();
    streamingSource = null;
  }
  if (streamingAudioContext) {
    streamingAudioContext.close();
    streamingAudioContext = null;
  }
  if (streamingStream) {
    streamingStream.getTracks().forEach(t => t.stop());
    streamingStream = null;
  }
  console.log('[WakeWord] Audio streaming stopped');
}

// ---- VAD (Voice Activity Detection) ----
async function initVAD() {
  if (vadInstance) return;

  setStatus('Initializing voice detection...', 'active');

  try {
    vadInstance = await vad.MicVAD.new({
      positiveSpeechThreshold: 0.9,
      negativeSpeechThreshold: 0.35,
      minSpeechFrames: 8,
      preSpeechPadFrames: 10,
      redemptionFrames: 20,
      onFrameProcessed: (probs) => {
        // Use VAD speech probability as audio level proxy
        updateAudioLevel(probs.isSpeech * 0.5);
      },
      onSpeechStart: () => {
        if (isSpeaking || isProcessing) {
          interrupt();
        }
        micBtn.classList.add('recording');
        setStatus('Listening...', 'listening');
      },
      onSpeechEnd: (audio) => {
        micBtn.classList.remove('recording');
        if (audio.length > SAMPLE_RATE * 0.3) {
          sendAudio(audio);
        } else {
          updateStatusForMode();
        }
      },
    });
    console.log('[VAD] Initialized');
  } catch (err) {
    console.error('[VAD] Init failed:', err);
    setStatus('VAD init failed: ' + err.message, '');
  }
}

async function startVAD() {
  if (!vadInstance) await initVAD();
  if (vadInstance) {
    vadInstance.start();
    micBtn.classList.add('vad-active');
    console.log('[VAD] Started');
  }
}

function stopVAD() {
  if (vadInstance) {
    vadInstance.pause();
  }
  micBtn.classList.remove('vad-active');
  micBtn.classList.remove('recording');
  console.log('[VAD] Stopped');
}

// ---- Send audio to server ----
function sendAudio(float32Audio) {
  const int16 = new Int16Array(float32Audio.length);
  for (let i = 0; i < float32Audio.length; i++) {
    int16[i] = Math.max(-32768, Math.min(32767, Math.round(float32Audio[i] * 32767)));
  }

  const b64 = arrayBufferToBase64(int16.buffer);
  ws.send(JSON.stringify({ type: 'audio', data: b64 }));
  isProcessing = true;
  setStatus('Processing...', 'active');
}

// ---- Manual recording (fallback) ----
let manualChunks = [];
let manualRecorder = null;
let manualStream = null;
let manualCtx = null;

async function startManualRecording() {
  // If in wake word mode and sleeping, wake up first
  if (wakeWordActive && clientState === 'sleeping') {
    // Manual button press = wake up
    handleWake();
    ws.send(JSON.stringify({ type: 'set_state', state: 'awake' }));
  }

  if (isSpeaking || isProcessing) {
    interrupt();
  }

  if (!manualStream) {
    try {
      manualStream = await navigator.mediaDevices.getUserMedia({
        audio: { sampleRate: SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true }
      });
    } catch (err) {
      if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
        showError('Mic access denied â€” enable microphone in browser settings', 6000);
      } else {
        showError('Could not access microphone: ' + err.message);
      }
      return;
    }
  }

  manualCtx = new AudioContext({ sampleRate: SAMPLE_RATE });
  const source = manualCtx.createMediaStreamSource(manualStream);
  const proc = manualCtx.createScriptProcessor(4096, 1, 1);

  manualChunks = [];
  proc.onaudioprocess = (e) => {
    const float32 = e.inputBuffer.getChannelData(0);
    manualChunks.push(new Float32Array(float32));
    // Audio level visualization during manual recording
    let sum = 0;
    for (let i = 0; i < float32.length; i++) sum += float32[i] * float32[i];
    updateAudioLevel(Math.sqrt(sum / float32.length));
  };

  source.connect(proc);
  proc.connect(manualCtx.destination);
  manualRecorder = { proc, source };

  // Pause VAD during manual recording
  if (vadInstance) vadInstance.pause();

  micBtn.classList.add('recording');
  setStatus('Listening...', 'listening');
}

function stopManualRecording() {
  if (!manualRecorder) return;

  micBtn.classList.remove('recording');
  updateAudioLevel(0);

  const { proc, source } = manualRecorder;
  proc.disconnect();
  source.disconnect();
  manualCtx.close();
  manualRecorder = null;

  const total = manualChunks.reduce((n, c) => n + c.length, 0);
  const merged = new Float32Array(total);
  let offset = 0;
  for (const chunk of manualChunks) {
    merged.set(chunk, offset);
    offset += chunk.length;
  }
  manualChunks = [];

  // Resume VAD if in awake mode
  if (clientState === 'awake' && wakeWordActive && vadInstance) {
    vadInstance.start();
  }

  if (merged.length < SAMPLE_RATE * 0.3) {
    setStatus('Too short â€” hold longer', 'active');
    return;
  }

  sendAudio(merged);
}

// ---- Audio Playback (legacy) ----
function playAudio(b64) {
  const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
  const blob = new Blob([bytes], { type: 'audio/wav' });
  const url = URL.createObjectURL(blob);
  const audio = new Audio(url);
  audio.play();
  audio.onended = () => URL.revokeObjectURL(url);
}

// ---- UI helpers ----
function setStatus(text, className = '') {
  statusEl.textContent = text;
  statusEl.className = className;
}

function updateStatusForMode() {
  if (wakeWordActive) {
    if (clientState === 'sleeping') {
      setStatus(`Say "${wakeWordName}" to wake me`, 'sleeping');
    } else {
      setStatus('Listening â€” talk anytime', 'active');
    }
  } else {
    setStatus('Ready â€” hold mic to talk', 'active');
  }
}

function addMessage(role, text, meta) {
  const div = document.createElement('div');
  div.className = `msg ${role}`;
  div.textContent = text;
  if (meta) {
    const m = document.createElement('div');
    m.className = 'meta';
    m.textContent = meta;
    div.appendChild(m);
  }
  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
}

function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

// ---- Event handlers ----
micBtn.addEventListener('mousedown', (e) => {
  e.preventDefault();
  startManualRecording();
});
micBtn.addEventListener('mouseup', (e) => {
  e.preventDefault();
  stopManualRecording();
});
micBtn.addEventListener('mouseleave', () => {
  if (manualRecorder) stopManualRecording();
});

micBtn.addEventListener('touchstart', (e) => {
  e.preventDefault();
  startManualRecording();
});
micBtn.addEventListener('touchend', (e) => {
  e.preventDefault();
  stopManualRecording();
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && !e.repeat && !manualRecorder) {
    e.preventDefault();
    startManualRecording();
  }
});
document.addEventListener('keyup', (e) => {
  if (e.code === 'Space' && manualRecorder) {
    e.preventDefault();
    stopManualRecording();
  }
});

wakeToggle.addEventListener('click', () => {
  if (!wakeWordEnabled) {
    setStatus('Wake word not available on server', 'active');
    return;
  }
  if (wakeWordActive) {
    disableWakeWordMode();
  } else {
    enableWakeWordMode();
  }
});

clearBtn.addEventListener('click', () => {
  chatEl.innerHTML = '';
  stopPlayback();
  ws.send(JSON.stringify({ type: 'clear' }));
});

// ---- Speaker Verification ----
const enrollBtn = document.getElementById('enrollBtn');
const verifyToggle = document.getElementById('verifyToggle');
const enrollModal = document.getElementById('enrollModal');
const enrollPrompt = document.getElementById('enrollPrompt');
const enrollProgress = document.getElementById('enrollProgress');
const enrollRecordBtn = document.getElementById('enrollRecordBtn');
const enrollCancelBtn = document.getElementById('enrollCancelBtn');
const enrollTitle = document.getElementById('enrollTitle');
const enrollDesc = document.getElementById('enrollDesc');
const enrollInfo = document.getElementById('enrollInfo');

let verifyEnabled = false;
let enrolled = false;
let lastVerifyScore = null;

const ENROLL_PROMPTS = [
  "The quick brown fox jumps over the lazy dog.",
  "How vexingly quick daft zebras jump.",
  "Pack my box with five dozen liquor jugs.",
  "She sells seashells by the seashore.",
  "A journey of a thousand miles begins with a single step.",
];
const ENROLL_REQUIRED = 3;
let enrollStep = 0;
let enrollRecording = false;
let enrollCtx = null;
let enrollChunks = [];
let enrollProc = null;
let enrollSource = null;

function updateVerifyUI() {
  if (enrolled) {
    enrollBtn.textContent = 'ðŸŽ¤ Re-enroll';
    verifyToggle.style.display = '';
    verifyToggle.textContent = verifyEnabled ? 'ðŸ”’ Verify: On' : 'ðŸ”“ Verify: Off';
    verifyToggle.classList.toggle('active', verifyEnabled);
  } else {
    enrollBtn.textContent = 'ðŸŽ¤ Enroll Voice';
    verifyToggle.style.display = 'none';
  }
}

function showEnrollModal() {
  enrollStep = 0;
  enrollModal.classList.add('show');
  ws.send(JSON.stringify({ type: 'enroll_start' }));
  updateEnrollStep();
}

function hideEnrollModal() {
  enrollModal.classList.remove('show');
  enrollRecording = false;
  enrollRecordBtn.textContent = 'ðŸŽ¤ Record';
}

function updateEnrollStep() {
  if (enrollStep >= ENROLL_REQUIRED) {
    // All done â€” finalize
    enrollPrompt.textContent = 'Processing enrollment...';
    enrollRecordBtn.style.display = 'none';
    enrollInfo.textContent = '';
    ws.send(JSON.stringify({ type: 'enroll_complete' }));
    return;
  }
  enrollPrompt.textContent = `"${ENROLL_PROMPTS[enrollStep]}"`;
  enrollInfo.textContent = `Sample ${enrollStep + 1} of ${ENROLL_REQUIRED}`;
  enrollRecordBtn.style.display = '';
  enrollRecordBtn.textContent = 'ðŸŽ¤ Hold to Record';
  enrollRecordBtn.disabled = false;

  // Update dots
  let dots = '';
  for (let i = 0; i < ENROLL_REQUIRED; i++) {
    const cls = i < enrollStep ? 'dot done' : i === enrollStep ? 'dot active' : 'dot';
    dots += `<div class="${cls}"></div>`;
  }
  enrollProgress.innerHTML = dots;
}

async function startEnrollRecording() {
  if (!manualStream) {
    manualStream = await navigator.mediaDevices.getUserMedia({
      audio: { sampleRate: SAMPLE_RATE, channelCount: 1, echoCancellation: true, noiseSuppression: true }
    });
  }
  enrollCtx = new AudioContext({ sampleRate: SAMPLE_RATE });
  enrollSource = enrollCtx.createMediaStreamSource(manualStream);
  enrollProc = enrollCtx.createScriptProcessor(4096, 1, 1);
  enrollChunks = [];
  enrollProc.onaudioprocess = (e) => {
    enrollChunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
  };
  enrollSource.connect(enrollProc);
  enrollProc.connect(enrollCtx.destination);
  enrollRecording = true;
  enrollRecordBtn.textContent = 'â¹ Recording...';
}

function stopEnrollRecording() {
  if (!enrollRecording) return;
  enrollRecording = false;
  if (enrollProc) enrollProc.disconnect();
  if (enrollSource) enrollSource.disconnect();
  if (enrollCtx) enrollCtx.close();

  const total = enrollChunks.reduce((n, c) => n + c.length, 0);
  if (total < SAMPLE_RATE * 0.5) {
    enrollRecordBtn.textContent = 'ðŸŽ¤ Too short, try again';
    return;
  }
  const merged = new Float32Array(total);
  let off = 0;
  for (const c of enrollChunks) { merged.set(c, off); off += c.length; }
  enrollChunks = [];

  // Convert to int16 PCM and send
  const int16 = new Int16Array(merged.length);
  for (let i = 0; i < merged.length; i++) {
    int16[i] = Math.max(-32768, Math.min(32767, Math.round(merged[i] * 32767)));
  }
  const b64 = arrayBufferToBase64(int16.buffer);
  ws.send(JSON.stringify({ type: 'enroll_sample', data: b64 }));
}

// Enrollment button â€” hold to record
enrollRecordBtn.addEventListener('mousedown', (e) => { e.preventDefault(); startEnrollRecording(); });
enrollRecordBtn.addEventListener('mouseup', (e) => { e.preventDefault(); stopEnrollRecording(); });
enrollRecordBtn.addEventListener('mouseleave', () => { if (enrollRecording) stopEnrollRecording(); });
enrollRecordBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startEnrollRecording(); });
enrollRecordBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopEnrollRecording(); });

enrollBtn.addEventListener('click', showEnrollModal);
enrollCancelBtn.addEventListener('click', () => {
  ws.send(JSON.stringify({ type: 'enroll_cancel' }));
  hideEnrollModal();
});

verifyToggle.addEventListener('click', () => {
  verifyEnabled = !verifyEnabled;
  ws.send(JSON.stringify({ type: 'toggle_verify', enabled: verifyEnabled }));
  updateVerifyUI();
});

// ---- Reconnect banner click ----
reconnectBanner.addEventListener('click', () => {
  reconnectAttempts = 0;
  reconnectBanner.classList.remove('show');
  setStatus('Reconnecting...', '');
  connect();
});

// ---- Init ----
connect();
</script>
</body>
</html>
